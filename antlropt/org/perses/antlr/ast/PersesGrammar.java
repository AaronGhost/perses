/*
 * Copyright (C) 2018-2020 University of Waterloo.
 *
 * This file is part of Perses.
 *
 * Perses is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 3, or (at your option) any later version.
 *
 * Perses is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * Perses; see the file LICENSE.  If not see <http://www.gnu.org/licenses/>.
 */
package org.perses.antlr.ast;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;

import java.io.PrintStream;
import java.util.Optional;
import java.util.function.Function;

public final class PersesGrammar extends AbstractPersesAst {

  public enum GrammarType {
    LEXER,

    PARSER,

    COMBINED;
  }

  private final GrammarType grammarType;
  private final String grammarName;
  private final PersesGrammarOptionsAst options;
  private final ImmutableList<PersesNamedAction> namedActions;
  private final ImmutableList<AbstractPersesRuleDefAst> rules;
  private final SymbolTable symbolTable;
  private final ImmutableMap<RuleNameRegistry.RuleNameHandle, AbstractPersesRuleDefAst>
      ruleNameToRuleMap;

  public PersesGrammar(
      GrammarType grammarType,
      String grammarName,
      PersesGrammarOptionsAst options,
      ImmutableList<PersesNamedAction> namedActions,
      ImmutableList<AbstractPersesRuleDefAst> rules,
      SymbolTable symbolTable) {
    this(
        grammarType,
        grammarName,
        options,
        namedActions,
        rules,
        symbolTable,
        rules.stream()
            .collect(
                ImmutableMap.toImmutableMap(
                    AbstractPersesRuleDefAst::getRuleNameHandle, Function.identity())));
  }

  private PersesGrammar(
      GrammarType grammarType,
      String grammarName,
      PersesGrammarOptionsAst options,
      ImmutableList<PersesNamedAction> namedActions,
      ImmutableList<AbstractPersesRuleDefAst> rules,
      SymbolTable symbolTable,
      ImmutableMap<RuleNameRegistry.RuleNameHandle, AbstractPersesRuleDefAst> ruleNameToRuleMap) {
    this.grammarType = grammarType;
    this.grammarName = grammarName;
    this.options = options;
    this.namedActions = namedActions;
    this.rules = rules;
    this.symbolTable = symbolTable;
    this.ruleNameToRuleMap = ruleNameToRuleMap;
  }

  public PersesGrammar copyWithNewName(String newGrammarName) {
    return new PersesGrammar(
        grammarType, newGrammarName, options, namedActions, rules, symbolTable, ruleNameToRuleMap);
  }

  public PersesGrammarOptionsAst getOptions() {
    return options;
  }

  public ImmutableList<PersesNamedAction> getNamedActions() {
    return namedActions;
  }

  public String getGrammarName() {
    return grammarName;
  }

  public GrammarType getGrammarType() {
    return grammarType;
  }

  public SymbolTable getSymbolTable() {
    return symbolTable;
  }

  public ImmutableList<AbstractPersesRuleDefAst> getRules() {
    return rules;
  }

  public Optional<AbstractPersesRuleDefAst> getRuleDefinition(String ruleName) {
    Optional<RuleNameRegistry.RuleNameHandle> ruleNameHandle =
        symbolTable.getRuleNameRegistry().get(ruleName);
    if (ruleNameHandle.isPresent()) {
      return getRuleDefinition(ruleNameHandle.get());
    } else {
      return Optional.empty();
    }
  }

  public Optional<AbstractPersesRuleDefAst> getRuleDefinition(
      RuleNameRegistry.RuleNameHandle ruleNameHandle) {
    AbstractPersesRuleDefAst def = ruleNameToRuleMap.get(ruleNameHandle);
    return Optional.ofNullable(def);
  }

  private static final int ZERO_INDENTS = 0;
  private static final boolean SINGLE_LINE_MODE = false;
  private static final boolean MULTI_LINE_MODE = true;

  public void toSourceCode(PrintStream stream, int indent, boolean multiLineMode) {
    stream.println("// Auto-generated by Perses AST.");
    stream.println("// DO NOT MODIFY.");

    switch (grammarType) {
      case LEXER:
        stream.print("lexer ");
        break;
      case PARSER:
        stream.print("parser ");
        break;
      case COMBINED:
        break;
      default:
        throw new RuntimeException("Unreachable.");
    }
    stream.printf("grammar %s;\n", grammarName);
    stream.println();

    options.toSourceCode(stream, ZERO_INDENTS, SINGLE_LINE_MODE);

    for (PersesNamedAction action : namedActions) {
      action.toSourceCode(stream, ZERO_INDENTS, SINGLE_LINE_MODE);
    }

    for (AbstractPersesRuleDefAst rule : rules) {
      rule.toSourceCode(stream, ZERO_INDENTS, MULTI_LINE_MODE);
      stream.println();
    }
  }

  @Override
  public int getChildCount() {
    return rules.size();
  }

  @Override
  public AbstractPersesRuleDefAst getChild(int index) {
    return rules.get(index);
  }

  @Override
  protected String getExtraLabelForTreeStructurePrinting() {
    return super.getExtraLabelForTreeStructurePrinting() + " grammar_name=" + grammarName;
  }

  @Override
  public AstTag getTag() {
    return AstTag.GRAMMAR;
  }

  public boolean isEquivalent(PersesGrammar other) {
    if (!ruleNameToRuleMap.keySet().equals(other.ruleNameToRuleMap.keySet())) {
      return false;
    }
    for (RuleNameRegistry.RuleNameHandle ruleNameHandle : ruleNameToRuleMap.keySet()) {
      if (!ruleNameToRuleMap
          .get(ruleNameHandle)
          .getBody()
          .isEquivalent(other.ruleNameToRuleMap.get(ruleNameHandle).getBody())) {
        return false;
      }
    }
    return true;
  }
}
